ðŸ“‚ PROJECT STRUCTURE (.go only):

â”œâ”€â”€ /cmd
â”‚   â””â”€â”€ main.go
â”œâ”€â”€ /data
â”‚   â””â”€â”€ main.go
â”œâ”€â”€ /docs
â”‚   â””â”€â”€ docs.go
â”œâ”€â”€ /internal
â”‚   â”œâ”€â”€ /app
â”‚   â”‚   â””â”€â”€ app.go
â”œâ”€â”€ /internal
â”‚   â”œâ”€â”€ /app
â”‚   â”‚   â””â”€â”€ service_provider.go
â”œâ”€â”€ /internal
â”‚   â”œâ”€â”€ /config
â”‚   â”‚   â””â”€â”€ config.go
â”œâ”€â”€ /internal
â”‚   â”œâ”€â”€ /config
â”‚   â”‚   â””â”€â”€ http.go
â”œâ”€â”€ /internal
â”‚   â”œâ”€â”€ /config
â”‚   â”‚   â””â”€â”€ jwt.go
â”œâ”€â”€ /internal
â”‚   â”œâ”€â”€ /config
â”‚   â”‚   â””â”€â”€ pg.go
â”œâ”€â”€ /internal
â”‚   â”œâ”€â”€ /config
â”‚   â”‚   â””â”€â”€ swagger.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â”œâ”€â”€ /converter
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ user.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â””â”€â”€ login.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ user.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â””â”€â”€ register.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â””â”€â”€ server.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /jwt
â”‚   â”‚   â”‚   â””â”€â”€ jwt.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /middleware
â”‚   â”‚   â”‚   â””â”€â”€ auth.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /middleware
â”‚   â”‚   â”‚   â””â”€â”€ server.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â””â”€â”€ errors.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â””â”€â”€ user.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /repository
â”‚   â”‚   â”‚   â”œâ”€â”€ /user
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ /converter
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ user.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /repository
â”‚   â”‚   â”‚   â”œâ”€â”€ /user
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ user.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /repository
â”‚   â”‚   â”‚   â”œâ”€â”€ /user
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ reposotiry.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â””â”€â”€ routes.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /service
â”‚   â”‚   â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ register.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”œâ”€â”€ /service
â”‚   â”‚   â”‚   â”œâ”€â”€ /auth
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ service.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /client
â”‚   â”‚   â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ order.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /client
â”‚   â”‚   â”‚   â”œâ”€â”€ /supplier
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ supplier.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â””â”€â”€ cart.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â””â”€â”€ checkout.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â”œâ”€â”€ /converter
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ add-product.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ put-card-input.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â””â”€â”€ server.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â””â”€â”€ cart.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â””â”€â”€ errors.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /repository
â”‚   â”‚   â”‚   â””â”€â”€ cart.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /repository
â”‚   â”‚   â”‚   â”œâ”€â”€ /converter
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ cart.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /repository
â”‚   â”‚   â”‚   â””â”€â”€ item.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /repository
â”‚   â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ get-cart.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /repository
â”‚   â”‚   â”‚   â””â”€â”€ repository.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â””â”€â”€ routes.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /service
â”‚   â”‚   â”‚   â””â”€â”€ cart.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /service
â”‚   â”‚   â”‚   â””â”€â”€ checkout.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /cart
â”‚   â”‚   â”œâ”€â”€ /service
â”‚   â”‚   â”‚   â””â”€â”€ service.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /client
â”‚   â”‚   â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ product.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /client
â”‚   â”‚   â”‚   â”œâ”€â”€ /supplier
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ supplier.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â”œâ”€â”€ /converter
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ order.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â””â”€â”€ handler.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ order.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â””â”€â”€ order.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â””â”€â”€ errors.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â””â”€â”€ order.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â””â”€â”€ role.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /repo
â”‚   â”‚   â”‚   â”œâ”€â”€ /converter
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ order-product.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /repo
â”‚   â”‚   â”‚   â”œâ”€â”€ /converter
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ order.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /repo
â”‚   â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ order-product.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /repo
â”‚   â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ order.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /repo
â”‚   â”‚   â”‚   â””â”€â”€ order-product.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /repo
â”‚   â”‚   â”‚   â””â”€â”€ order.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /repo
â”‚   â”‚   â”‚   â””â”€â”€ repo.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â””â”€â”€ routes.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /service
â”‚   â”‚   â”‚   â””â”€â”€ order.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /order
â”‚   â”‚   â”œâ”€â”€ /service
â”‚   â”‚   â”‚   â””â”€â”€ service.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â”œâ”€â”€ /converter
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ catalog.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â”œâ”€â”€ /converter
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ product-list.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â””â”€â”€ getProduct.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â””â”€â”€ getProductList.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ catalog.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page-count.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ product.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â””â”€â”€ server.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â””â”€â”€ errors.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â””â”€â”€ page-count.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â””â”€â”€ product.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /repository
â”‚   â”‚   â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ /converter
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ product.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /repository
â”‚   â”‚   â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ product.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /repository
â”‚   â”‚   â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ reposotiry.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â””â”€â”€ routes.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /service
â”‚   â”‚   â”‚   â””â”€â”€ product-list.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /service
â”‚   â”‚   â”‚   â””â”€â”€ product.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /product
â”‚   â”‚   â”œâ”€â”€ /service
â”‚   â”‚   â”‚   â””â”€â”€ service.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /supplier
â”‚   â”‚   â”œâ”€â”€ /handler
â”‚   â”‚   â”‚   â””â”€â”€ handler.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /supplier
â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â””â”€â”€ supplier.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /supplier
â”‚   â”‚   â”œâ”€â”€ /repo
â”‚   â”‚   â”‚   â”œâ”€â”€ /converter
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ supplier.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /supplier
â”‚   â”‚   â”œâ”€â”€ /repo
â”‚   â”‚   â”‚   â”œâ”€â”€ /model
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ supplier.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /supplier
â”‚   â”‚   â”œâ”€â”€ /repo
â”‚   â”‚   â”‚   â””â”€â”€ repo.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /supplier
â”‚   â”‚   â”œâ”€â”€ /repo
â”‚   â”‚   â”‚   â””â”€â”€ supplier.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /supplier
â”‚   â”‚   â””â”€â”€ routes.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /supplier
â”‚   â”‚   â”œâ”€â”€ /service
â”‚   â”‚   â”‚   â””â”€â”€ service.go
â”œâ”€â”€ /modules
â”‚   â”œâ”€â”€ /supplier
â”‚   â”‚   â”œâ”€â”€ /service
â”‚   â”‚   â”‚   â””â”€â”€ supplier.go
â”œâ”€â”€ /pkg
â”‚   â”œâ”€â”€ /client
â”‚   â”‚   â”œâ”€â”€ /db
â”‚   â”‚   â”‚   â””â”€â”€ db.go
â”œâ”€â”€ /pkg
â”‚   â”œâ”€â”€ /client
â”‚   â”‚   â”œâ”€â”€ /db
â”‚   â”‚   â”‚   â”œâ”€â”€ /pg
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ client.go
â”œâ”€â”€ /pkg
â”‚   â”œâ”€â”€ /client
â”‚   â”‚   â”œâ”€â”€ /db
â”‚   â”‚   â”‚   â”œâ”€â”€ /pg
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ pg.go
â”œâ”€â”€ /pkg
â”‚   â”œâ”€â”€ /client
â”‚   â”‚   â”œâ”€â”€ /db
â”‚   â”‚   â”‚   â”œâ”€â”€ /prettier
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ query_prettier.go
â”œâ”€â”€ /pkg
â”‚   â”œâ”€â”€ /client
â”‚   â”‚   â”œâ”€â”€ /db
â”‚   â”‚   â”‚   â”œâ”€â”€ /transaction
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ transaction.go
â”œâ”€â”€ /pkg
â”‚   â”œâ”€â”€ /closer
â”‚   â”‚   â””â”€â”€ closer.go
â”œâ”€â”€ /pkg
â”‚   â”œâ”€â”€ /context-keys
â”‚   â”‚   â””â”€â”€ key.go
â”œâ”€â”€ /pkg
â”‚   â”œâ”€â”€ /password-util
â”‚   â”‚   â””â”€â”€ password-util.go
â”œâ”€â”€ /pkg
â”‚   â”œâ”€â”€ /validator
â”‚   â”‚   â””â”€â”€ validator.go
â”‚   â””â”€â”€ txt.go


ðŸ“„ GO FILES CONTENT:

cmd/main.go
--------------------------------------------------------------------------------
package main

import (
	"context"
	"diploma/internal/app"
	"log"
)

// @title Go JWT Swagger Example API
// @description This is a sample server with JWT authorization.
// @version 1.0

// @SecurityDefinitions.bearer

// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name Authorization

func main() {
	ctx := context.Background()

	a, err := app.NewApp(ctx)
	if err != nil {
		log.Fatalf("failed to init app: %s", err.Error())
	}

	err = a.Run()
	if err != nil {
		log.Fatalf("failed to run app: %s", err.Error())
	}
}


data/main.go
--------------------------------------------------------------------------------
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
	"golang.org/x/crypto/bcrypt"
)

// DeliveryCondition structure for delivery_conditions.json
type DeliveryCondition struct {
	ConditionID               int     `json:"condition_id"`
	MinimumFreeDeliveryAmount float64 `json:"minimum_free_delivery_amount"`
	DeliveryFee               float64 `json:"delivery_fee"`
}

// Supplier structure for suppliers.json
type Supplier struct {
	UserID      int `json:"user_id"`
	Name        string
	ConditionID int `json:"condition_id"`
}

// Product structure for products.json
type Product struct {
	ID         int    `json:"id"`
	Name       string `json:"name"`
	ImageURL   string `json:"image_url"`
	GTIN       int64  `json:"gtin"`
	MinPrice   int    `json:"min_price"`
	SupplierID int    `json:"supplier_id"`
}

// ProductSupplier structure for products_supplier.json
type ProductSupplier struct {
	ProductID     int `json:"product_id"`
	SupplierID    int `json:"supplier_id"`
	Price         int `json:"price"`
	MinSellAmount int `json:"min_sell_amount"`
}

func generatePhoneNumber(userID int) string {
	// For example, we generate a phone number by prefixing with a fixed code
	// You can customize the logic as needed
	return fmt.Sprintf("+1234567%d", userID)
}

// Function to generate a hashed password (same for each user)
func generateHashedPassword() (string, error) {
	// The password we want to hash (same for every user)
	const password = "password1@"

	// Generate the bcrypt hash
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}

	return string(hashedPassword), nil
}

func generateOrderAmountByIndex(index int) int {
	orderAmounts := []int{30000, 50000, 70000, 100000, 150000}
	return orderAmounts[index%len(orderAmounts)]
}

func insertSupplier(db *sqlx.DB, suppliers []Supplier) {
	for i, supplier := range suppliers {
		phoneNumber := generatePhoneNumber(supplier.UserID)
		hashedPassword, err := generateHashedPassword()
		if err != nil {
			log.Fatalf("Error generating password: %v", err)
		}

		_, err = db.Exec(`INSERT INTO users (id, name, phone_number, hashed_password, role) 
							VALUES ($1, $2, $3, $4, 1)`, supplier.UserID, supplier.Name, phoneNumber, hashedPassword)
		if err != nil {
			log.Fatalf("Error inserting user: %v", err)
		}

		orderAmount := generateOrderAmountByIndex(i)
		_, err = db.Exec(`INSERT INTO suppliers (user_id, condition_id, name ,order_amount) 
							VALUES ($1, $2, $3, $4)`, supplier.UserID, supplier.ConditionID, supplier.Name, orderAmount)
		if err != nil {
			log.Fatalf("Error inserting supplier: %v", err)
		}
	}
}

func updateProductPrices(db *sqlx.DB) error {
	// Query to get the lowest price and the supplier_id for each product
	rows, err := db.Query(`
		SELECT ps.product_id, ps.price AS lowest_price, ps.supplier_id
		FROM products_supplier ps
		WHERE ps.price = (
			SELECT MIN(price)
			FROM products_supplier
			WHERE product_id = ps.product_id
		)
		GROUP BY ps.product_id, ps.supplier_id, ps.price;
	`)
	if err != nil {
		return fmt.Errorf("error querying lowest prices and supplier ids: %v", err)
	}
	defer rows.Close()

	// Prepare the update query for setting the lowest_price and lowest_supplier_id in the 'products' table
	updateQuery := `UPDATE products SET lowest_price = $1, lowest_supplier_id = $2 WHERE id = $3`

	// Iterate through the results and update the 'products' table
	for rows.Next() {
		var productID int
		var lowestPrice int
		var lowestSupplierID int

		// Scan the results
		if err := rows.Scan(&productID, &lowestPrice, &lowestSupplierID); err != nil {
			return fmt.Errorf("error scanning row: %v", err)
		}

		// Update the 'lowest_price' and 'lowest_supplier_id' in the 'products' table
		_, err := db.Exec(updateQuery, lowestPrice, lowestSupplierID, productID)
		if err != nil {
			return fmt.Errorf("error updating product: %v", err)
		}
	}

	// Check for any error that might have occurred during row iteration
	if err := rows.Err(); err != nil {
		return fmt.Errorf("error iterating through rows: %v", err)
	}

	return nil
}

func main() {
	// Open connection to your PostgreSQL database
	connStr := "host=localhost port=5432 dbname=catalog user=note-user password=note-password sslmode=disable"
	db, err := sqlx.Connect("postgres", connStr)
	if err != nil {
		log.Fatalln(err)
	}
	defer db.Close()

	// Read JSON files
	// Delivery Conditions
	deliveryConditions := []DeliveryCondition{}
	loadJSON("delivery_conditions.json", &deliveryConditions)

	// Insert into delivery_conditions
	for _, condition := range deliveryConditions {
		_, err := db.Exec(`INSERT INTO delivery_conditions (condition_id, minimum_free_delivery_amount, delivery_fee)
							VALUES ($1, $2, $3)`, condition.ConditionID, condition.MinimumFreeDeliveryAmount, condition.DeliveryFee)
		if err != nil {
			log.Fatalf("Error inserting delivery condition: %v", err)
		}
	}

	// // Suppliers
	suppliers := []Supplier{}
	loadJSON("suppliers.json", &suppliers)
	fmt.Println("Suppliers")
	insertSupplier(db, suppliers)

	// Products
	products := []Product{}
	loadJSON("products.json", &products)

	fmt.Println(products)
	// Insert into products
	for _, product := range products {
		_, err := db.Exec(`INSERT INTO products (id, name, image_url, gtin)
							VALUES ($1, $2, $3, $4)`, product.ID, product.Name, product.ImageURL, product.GTIN)
		if err != nil {
			fmt.Println(product)
			log.Fatalf("Error inserting product: %v", err)
		}
	}

	// Products Supplier
	productSuppliers := []ProductSupplier{}
	loadJSON("products_supplier.json", &productSuppliers)
	fmt.Print("Products Supplier")
	// Insert into products_supplier
	for _, ps := range productSuppliers {
		_, err := db.Exec(`INSERT INTO products_supplier (product_id, supplier_id, price, sell_amount)
							VALUES ($1, $2, $3, $4)`, ps.ProductID, ps.SupplierID, ps.Price, ps.MinSellAmount)
		if err != nil {
			fmt.Println(ps)
			// log.Fatalf("Error inserting product supplier: %v", err)
		}
	}

	fmt.Println("updating products_supplier")
	err = updateProductPrices(db)
	if err != nil {
		log.Fatalf("Error updating product prices: %v", err)
	}

	fmt.Println("Data migration completed successfully!")
}

// LoadJSON reads the JSON file and unmarshals it into the provided interface{}
func loadJSON(fileName string, data interface{}) {
	file, err := os.Open(fileName)
	if err != nil {
		log.Fatalf("Error opening file: %v", err)
	}
	defer file.Close()

	decoder := json.NewDecoder(file)
	err = decoder.Decode(&data)
	if err != nil {
		log.Fatalf("Error decoding JSON: %v", err)
	}
}


docs/docs.go
--------------------------------------------------------------------------------
// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/auth/login": {
            "post": {
                "description": "Login user and return tokens",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "Login input",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/model.LoginInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.LoginResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/diploma_modules_auth_handler_model.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/auth/register": {
            "post": {
                "description": "Register a new user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "User registration",
                "parameters": [
                    {
                        "description": "Register input",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/model.RegisterInput"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/model.RegisterResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/diploma_modules_auth_handler_model.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/cart": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "--",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "cart"
                ],
                "summary": "get cart",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.GetCartResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/diploma_modules_cart_handler_model.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/cart/add": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "--",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "cart"
                ],
                "summary": "Put product to Card",
                "parameters": [
                    {
                        "description": "Put Card input",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/model.AddProductToCartInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.AddProductToCardResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/diploma_modules_cart_handler_model.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/cart/checkout": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Processes the checkout of the authenticated user's cart.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "cart"
                ],
                "summary": "Process checkout operation",
                "responses": {
                    "200": {
                        "description": "Checkout status",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/diploma_modules_cart_handler_model.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/diploma_modules_cart_handler_model.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/cart/delete": {
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Deletes given quantity of product by product_id and supplier_id from cart",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "cart"
                ],
                "summary": "Delete product from cart",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Product ID",
                        "name": "product_id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Supplier ID",
                        "name": "supplier_id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Quantity to delete (default 1)",
                        "name": "quantity",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/order": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Retrieves orders for the authenticated user using the provided JWT claims.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Retrieve orders for a user",
                "responses": {
                    "200": {
                        "description": "List of orders",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/model.GetOrdersResponse"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized: invalid or missing JWT token",
                        "schema": {
                            "$ref": "#/definitions/diploma_modules_order_handler_model.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error while retrieving orders",
                        "schema": {
                            "$ref": "#/definitions/diploma_modules_order_handler_model.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/order/status": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Supplier updates the status of their order",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Update order status by supplier",
                "parameters": [
                    {
                        "description": "Order ID and New Status",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/model.UpdateOrderStatusRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "status updated",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/diploma_modules_order_handler_model.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/diploma_modules_order_handler_model.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal error",
                        "schema": {
                            "$ref": "#/definitions/diploma_modules_order_handler_model.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/product/:id": {
            "get": {
                "description": "Register a new user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "product"
                ],
                "summary": "User registration",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "product id",
                        "name": "product_id",
                        "in": "query"
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/model.ProductResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/diploma_modules_product_handler_model.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/product/list": {
            "get": {
                "description": "Retrieve a list of products with pagination support using limit and offset",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "product"
                ],
                "summary": "Get product list",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Limit number of products",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Offset for pagination",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.ProductListResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/diploma_modules_product_handler_model.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "diploma_modules_auth_handler_model.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                }
            }
        },
        "diploma_modules_cart_handler_model.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                }
            }
        },
        "diploma_modules_cart_handler_model.Product": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "image": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "price": {
                    "type": "integer"
                },
                "quantity": {
                    "type": "integer"
                }
            }
        },
        "diploma_modules_cart_handler_model.Supplier": {
            "type": "object",
            "properties": {
                "delivery_fee": {
                    "type": "integer"
                },
                "free_delivery_amount": {
                    "type": "integer"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "orderAmount": {
                    "type": "integer"
                },
                "product_list": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/diploma_modules_cart_handler_model.Product"
                    }
                },
                "total_amount": {
                    "type": "integer"
                }
            }
        },
        "diploma_modules_order_handler_model.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                }
            }
        },
        "diploma_modules_order_handler_model.Order": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "order_date": {
                    "type": "string"
                },
                "product_list": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/diploma_modules_order_handler_model.Product"
                    }
                },
                "status": {
                    "type": "string"
                },
                "supplier": {
                    "$ref": "#/definitions/diploma_modules_order_handler_model.Supplier"
                }
            }
        },
        "diploma_modules_order_handler_model.Product": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "image": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "price": {
                    "type": "integer"
                },
                "quantity": {
                    "type": "integer"
                }
            }
        },
        "diploma_modules_order_handler_model.Supplier": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "diploma_modules_product_handler_model.DetailedProduct": {
            "type": "object",
            "properties": {
                "product": {
                    "$ref": "#/definitions/diploma_modules_product_handler_model.Product"
                },
                "suppliers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/diploma_modules_product_handler_model.ProductSupplier"
                    }
                }
            }
        },
        "diploma_modules_product_handler_model.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                }
            }
        },
        "diploma_modules_product_handler_model.Product": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "imageUrl": {
                    "type": "string"
                },
                "lowest_product_supplier": {
                    "$ref": "#/definitions/diploma_modules_product_handler_model.ProductSupplier"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "diploma_modules_product_handler_model.ProductSupplier": {
            "type": "object",
            "properties": {
                "price": {
                    "type": "integer"
                },
                "sell_amount": {
                    "type": "integer"
                },
                "supplier": {
                    "$ref": "#/definitions/diploma_modules_product_handler_model.Supplier"
                }
            }
        },
        "diploma_modules_product_handler_model.Supplier": {
            "type": "object",
            "properties": {
                "delivery_fee": {
                    "type": "integer"
                },
                "free_delivery_amount": {
                    "type": "integer"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "order_amount": {
                    "type": "integer"
                }
            }
        },
        "model.AddProductToCardResponse": {
            "type": "object",
            "properties": {
                "status": {
                    "type": "string"
                }
            }
        },
        "model.AddProductToCartInput": {
            "type": "object",
            "properties": {
                "product_id": {
                    "type": "integer"
                },
                "quantity": {
                    "type": "integer"
                },
                "supplier_id": {
                    "type": "integer"
                }
            }
        },
        "model.GetCartResponse": {
            "type": "object",
            "properties": {
                "customer_id": {
                    "type": "integer"
                },
                "suppliers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/diploma_modules_cart_handler_model.Supplier"
                    }
                },
                "total": {
                    "type": "integer"
                }
            }
        },
        "model.GetOrdersResponse": {
            "type": "object",
            "properties": {
                "orders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/diploma_modules_order_handler_model.Order"
                    }
                }
            }
        },
        "model.LoginInput": {
            "type": "object",
            "properties": {
                "password": {
                    "type": "string",
                    "example": "secure123"
                },
                "phone_number": {
                    "type": "string",
                    "example": "+123456789"
                }
            }
        },
        "model.LoginResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string"
                },
                "refresh_token": {
                    "type": "string"
                }
            }
        },
        "model.ProductListResponse": {
            "type": "object",
            "properties": {
                "product_list": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/diploma_modules_product_handler_model.Product"
                    }
                },
                "total": {
                    "type": "integer"
                }
            }
        },
        "model.ProductResponse": {
            "type": "object",
            "properties": {
                "product": {
                    "$ref": "#/definitions/diploma_modules_product_handler_model.DetailedProduct"
                }
            }
        },
        "model.RegisterInput": {
            "type": "object",
            "properties": {
                "confirm_password": {
                    "type": "string",
                    "example": "secure123"
                },
                "name": {
                    "type": "string",
                    "example": "John Doe"
                },
                "password": {
                    "type": "string",
                    "example": "secure123"
                },
                "phone_number": {
                    "type": "string",
                    "example": "+123456789"
                }
            }
        },
        "model.RegisterResponse": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer",
                    "example": 1
                }
            }
        },
        "model.UpdateOrderStatusRequest": {
            "type": "object",
            "required": [
                "new_status_id",
                "order_id"
            ],
            "properties": {
                "new_status_id": {
                    "type": "integer"
                },
                "order_id": {
                    "type": "integer"
                }
            }
        }
    },
    "securityDefinitions": {
        "ApiKeyAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "",
	BasePath:         "",
	Schemes:          []string{},
	Title:            "Go JWT Swagger Example API",
	Description:      "This is a sample server with JWT authorization.",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}


internal/app/app.go
--------------------------------------------------------------------------------
package app

import (
	"context"
	"diploma/docs"
	"diploma/internal/config"
	"diploma/modules/auth"
	"diploma/modules/cart"
	"diploma/modules/order"
	"diploma/modules/product"

	"log"
	"sync"

	"github.com/gin-gonic/gin"
	"github.com/rs/cors"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

type App struct {
	serviceProvider *serviceProvider
	httpServer      *gin.Engine
}

func NewApp(ctx context.Context) (*App, error) {
	app := &App{}

	err := app.initDeps(ctx)
	if err != nil {
		return nil, err
	}

	return app, nil
}

func (a *App) Run() error {
	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		defer wg.Done()
		if err := a.httpServerRun(); err != nil {
			log.Fatalf("HTTP server error: %v", err)
		}
	}()

	wg.Wait()
	return nil
}

func (a *App) initDeps(ctx context.Context) error {
	inits := []func(context.Context) error{
		a.initConfig,
		a.initServiceProvider,
		a.initHTTPServer,
	}

	for _, f := range inits {
		err := f(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (a *App) initConfig(_ context.Context) error {
	err := config.Load(".env")
	if err != nil {
		return err
	}

	return nil
}

func (a *App) initServiceProvider(_ context.Context) error {
	a.serviceProvider = newServiceProvider()
	return nil
}

func (a *App) initHTTPServer(ctx context.Context) error {
	router := gin.Default()

	corsMiddleware := cors.New(cors.Options{
		AllowedOrigins:   []string{"http://localhost:3000"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Content-Type", "Authorization"},
		AllowCredentials: true,
	})
	router.Use(func(c *gin.Context) {
		corsMiddleware.HandlerFunc(c.Writer, c.Request)
		c.Next()
	})

	docs.SwaggerInfo.BasePath = ""
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	apiGroup := router.Group("/api")

	authHandler := a.serviceProvider.AuthHandler(ctx)
	auth.RegisterRoutes(apiGroup, authHandler)
	authMiddleware := a.serviceProvider.AuthMiddleware(ctx)

	productHandler := a.serviceProvider.ProductHandler(ctx)
	product.RegisterRoutes(apiGroup, productHandler)

	secureGroup := router.Group("/api")
	secureGroup.Use(authMiddleware.AuthMiddleware())

	cartGroup := a.serviceProvider.CartHandler(ctx)
	cart.RegisterRoutes(secureGroup, cartGroup)

	orderHandler := a.serviceProvider.OrderHandler(ctx)
	order.RegisterRoutes(secureGroup, orderHandler)

	a.httpServer = router
	return nil
}

func (a *App) httpServerRun() error {
	address := a.serviceProvider.HTTPConfig().Address()
	log.Printf("HTTP server is running on %s", address)
	return a.httpServer.Run(address)
}


internal/app/service_provider.go
--------------------------------------------------------------------------------
package app

import (
	"context"
	"log"

	"diploma/internal/config"

	"diploma/pkg/client/db"
	"diploma/pkg/client/db/pg"
	"diploma/pkg/client/db/transaction"
	"diploma/pkg/closer"

	authApi "diploma/modules/auth/handler"
	authJWT "diploma/modules/auth/jwt"
	authMiddlware "diploma/modules/auth/middleware"
	userRepository "diploma/modules/auth/repository/user"
	authService "diploma/modules/auth/service/auth"

	productApi "diploma/modules/product/handler"
	productRepository "diploma/modules/product/repository/product"
	productService "diploma/modules/product/service"

	cartOrderClient "diploma/modules/cart/client/order"
	cartSupplierClient "diploma/modules/cart/client/supplier"
	cartApi "diploma/modules/cart/handler"
	cartRepository "diploma/modules/cart/repository"
	cartService "diploma/modules/cart/service"

	supplierRepository "diploma/modules/supplier/repo"
	supplierService "diploma/modules/supplier/service"

	orderProductClient "diploma/modules/order/client/product"
	orderSupplierCleint "diploma/modules/order/client/supplier"
	orderHander "diploma/modules/order/handler"
	orderRepository "diploma/modules/order/repo"

	// orderProductClient "diploma/modules/order/client/product"
	orderService "diploma/modules/order/service"
)

type serviceProvider struct {
	pgConfig      config.PGConfig
	jwtConfig     config.JWTConfig
	httpConfig    config.HTTPConfig
	swaggerConfig config.SwaggerConfig

	dbClient  db.Client
	txManager db.TxManager

	// auth
	authRepository authService.IAuthRepository
	authJWT        *authJWT.JSONWebToken
	authService    authApi.IAuthService
	authHanlder    *authApi.AuthHandler
	authMiddlware  *authMiddlware.AuthMiddleware

	// product

	productRepository productService.IProductRepository
	productService    *productService.ProductService
	productHanlder    *productApi.CatalogHandler

	// cart
	cartSupplierClient cartService.ISupplierClient
	cartOrderClient    cartService.IOrderClient
	cartRepository     cartService.ICartRepository
	cartService        cartApi.ICartService
	cartHanlder        *cartApi.CartHandler

	// supplier
	supplierRepository supplierService.ISupplierRepository
	supplierService    *supplierService.SupplierService

	// order
	// orderHandler  *orderHandler.OrderHandler
	orderRepository     orderService.IOrderRepository
	orderSupplierCleint orderService.ISupplierClient
	orderProductClient  orderService.IProductClient
	orderService        *orderService.OrderService
	orderHandler        *orderHander.OrderHandler
}

func newServiceProvider() *serviceProvider {
	return &serviceProvider{}
}

func (s *serviceProvider) PGConfig() config.PGConfig {
	if s.pgConfig == nil {
		cfg, err := config.NewPGConfig()
		if err != nil {
			log.Fatalf("failed to get pg config: %s", err.Error())
		}

		s.pgConfig = cfg
	}

	return s.pgConfig
}

func (s *serviceProvider) JWTConfig() config.JWTConfig {
	if s.jwtConfig == nil {
		cfg, err := config.NewJWTConfig()
		if err != nil {
			log.Fatalf("failed to get jwt config: %s", err.Error())
		}

		s.jwtConfig = cfg
	}

	return s.jwtConfig
}

func (s *serviceProvider) HTTPConfig() config.HTTPConfig {
	if s.httpConfig == nil {
		cfg, err := config.NewHTTPConfig()
		if err != nil {
			log.Fatalf("failed to get http config: %s", err.Error())
		}

		s.httpConfig = cfg
	}

	return s.httpConfig
}

func (s *serviceProvider) SwaggerConfig() config.SwaggerConfig {
	if s.swaggerConfig == nil {
		cfg, err := config.NewSwaggerConfig()
		if err != nil {
			log.Fatalf("failed to get swagger config: %s", err.Error())
		}

		s.swaggerConfig = cfg
	}

	return s.swaggerConfig
}

func (s *serviceProvider) DBClient(ctx context.Context) db.Client {
	if s.dbClient == nil {
		cl, err := pg.New(ctx, s.PGConfig().DSN())
		if err != nil {
			log.Fatalf("failed to create db client: %v", err)
		}

		err = cl.DB().Ping(ctx)
		if err != nil {
			log.Fatalf("ping error: %s", err.Error())
		}
		closer.Add(cl.Close)

		s.dbClient = cl
	}

	return s.dbClient
}

func (s *serviceProvider) TxManager(ctx context.Context) db.TxManager {
	if s.txManager == nil {
		s.txManager = transaction.NewTransactionManager(s.DBClient(ctx).DB())
	}

	return s.txManager
}

// ========= authentication =========
func (s *serviceProvider) AuthRepository(ctx context.Context) authService.IAuthRepository {
	if s.authRepository == nil {
		s.authRepository = userRepository.NewRepository(s.DBClient(ctx))
	}

	return s.authRepository
}

func (s *serviceProvider) JWT(ctx context.Context) *authJWT.JSONWebToken {
	if s.authJWT == nil {
		s.authJWT = authJWT.NewJSONWebToken(s.JWTConfig().GetSecretKey())
	}

	return s.authJWT
}

func (s *serviceProvider) AuthService(ctx context.Context) authApi.IAuthService {
	if s.authService == nil {
		s.authService = authService.NewService(s.AuthRepository(ctx), s.JWT(ctx), s.TxManager(ctx))
	}

	return s.authService
}

func (s *serviceProvider) AuthHandler(ctx context.Context) *authApi.AuthHandler {
	if s.authHanlder == nil {
		s.authHanlder = authApi.NewHandler(s.AuthService(ctx))
	}

	return s.authHanlder
}

func (s *serviceProvider) AuthMiddleware(ctx context.Context) *authMiddlware.AuthMiddleware {
	if s.authMiddlware == nil {
		s.authMiddlware = authMiddlware.NewAuthMiddleware(s.JWT(ctx))
	}

	return s.authMiddlware
}

// ========= product =========

func (s *serviceProvider) ProductRepository(ctx context.Context) productService.IProductRepository {
	if s.productRepository == nil {
		s.productRepository = productRepository.NewRepository(s.DBClient(ctx))
	}

	return s.productRepository
}

func (s *serviceProvider) ProductService(ctx context.Context) *productService.ProductService {
	if s.productService == nil {
		s.productService = productService.NewService(s.ProductRepository(ctx), s.TxManager(ctx))
	}

	return s.productService
}

func (s *serviceProvider) ProductHandler(ctx context.Context) *productApi.CatalogHandler {
	if s.productHanlder == nil {
		s.productHanlder = productApi.NewHandler(s.ProductService(ctx))
	}

	return s.productHanlder
}

// ========= suppliers =========

func (s *serviceProvider) SupplierRepo(ctx context.Context) supplierService.ISupplierRepository {
	if s.supplierRepository == nil {
		s.supplierRepository = supplierRepository.NewRepository(s.DBClient(ctx))
	}

	return s.supplierRepository
}

func (s *serviceProvider) SupplierService(ctx context.Context) *supplierService.SupplierService {
	if s.supplierService == nil {
		s.supplierService = supplierService.NewService(s.SupplierRepo(ctx), s.TxManager(ctx))
	}

	return s.supplierService
}

// ========= cart =========

func (s *serviceProvider) CartRepo(ctx context.Context) cartService.ICartRepository {
	if s.cartRepository == nil {
		s.cartRepository = cartRepository.NewRepository(s.DBClient(ctx))
	}

	return s.cartRepository

}

func (s *serviceProvider) CartSupplierClient(ctx context.Context) cartService.ISupplierClient {
	if s.cartSupplierClient == nil {
		s.cartSupplierClient = cartSupplierClient.NewClient(s.SupplierService(ctx))
	}

	return s.cartSupplierClient
}

func (s *serviceProvider) CartOrderClient(ctx context.Context) cartService.IOrderClient {
	if s.cartOrderClient == nil {
		s.cartOrderClient = cartOrderClient.NewClient(s.OrderService(ctx))
	}

	return s.cartOrderClient
}

func (s *serviceProvider) CartService(ctx context.Context) cartApi.ICartService {
	if s.cartService == nil {
		s.cartService = cartService.NewService(s.CartRepo(ctx), s.ProductService(ctx), s.CartSupplierClient(ctx), s.CartOrderClient(ctx), s.TxManager(ctx))
	}

	return s.cartService
}

func (s *serviceProvider) CartHandler(ctx context.Context) *cartApi.CartHandler {
	if s.cartHanlder == nil {
		s.cartHanlder = cartApi.NewHandler(s.CartService(ctx))
	}

	return s.cartHanlder
}

// order

func (s *serviceProvider) OrderSupplierClient(ctx context.Context) orderService.ISupplierClient {
	if s.orderSupplierCleint == nil {
		s.orderSupplierCleint = orderSupplierCleint.NewClient(s.SupplierService(ctx))
	}

	return s.orderSupplierCleint
}

func (s *serviceProvider) OrderProductClient(ctx context.Context) orderService.IProductClient {
	if s.orderProductClient == nil {
		s.orderProductClient = orderProductClient.NewClient(s.ProductService(ctx))
	}

	return s.orderProductClient
}

func (s *serviceProvider) OrderRepo(ctx context.Context) orderService.IOrderRepository {
	if s.orderRepository == nil {
		s.orderRepository = orderRepository.NewRepository(s.DBClient(ctx))
	}

	return s.orderRepository
}

func (s *serviceProvider) OrderService(ctx context.Context) *orderService.OrderService {
	if s.orderService == nil {
		s.orderService = orderService.NewService(s.OrderRepo(ctx), s.OrderSupplierClient(ctx), s.OrderProductClient(ctx), s.TxManager(ctx))
	}

	return s.orderService
}

func (s *serviceProvider) OrderHandler(ctx context.Context) *orderHander.OrderHandler {
	if s.orderHandler == nil {
		s.orderHandler = orderHander.NewHandler(s.OrderService(ctx))
	}

	return s.orderHandler
}


internal/config/config.go
--------------------------------------------------------------------------------
package config

import (
	"github.com/joho/godotenv"
)

func Load(path string) error {
	err := godotenv.Load(path)
	if err != nil {
		return err
	}

	return nil
}


internal/config/http.go
--------------------------------------------------------------------------------
package config

import (
	"net"
	"os"

	"github.com/pkg/errors"
)

const (
	httpHostEnvName = "HTTP_HOST"
	httpPortEnvName = "HTTP_PORT"
)

type HTTPConfig interface {
	Address() string
}

type httpConfig struct {
	host string
	port string
}

func NewHTTPConfig() (HTTPConfig, error) {
	host := os.Getenv(httpHostEnvName)
	if len(host) == 0 {
		return nil, errors.New("http host not found")
	}

	port := os.Getenv(httpPortEnvName)
	if len(port) == 0 {
		return nil, errors.New("http port not found")
	}

	return &httpConfig{
		host: host,
		port: port,
	}, nil
}

func (cfg *httpConfig) Address() string {
	return net.JoinHostPort(cfg.host, cfg.port)
}


internal/config/jwt.go
--------------------------------------------------------------------------------
package config

import (
	"os"

	"github.com/pkg/errors"
)

const (
	jwtSecretKey = "JWT_SECRET_KEY"
)

type JWTConfig interface {
	GetSecretKey() string
}

type jwtConfig struct {
	secretKey string
}

func NewJWTConfig() (JWTConfig, error) {
	secretKey := os.Getenv(jwtSecretKey)
	if len(secretKey) == 0 {
		return nil, errors.New("jwt secret key not found")
	}

	return &jwtConfig{
		secretKey: secretKey,
	}, nil
}

func (cfg *jwtConfig) GetSecretKey() string {
	return cfg.secretKey
}


internal/config/pg.go
--------------------------------------------------------------------------------
package config

import (
	"errors"
	"fmt"
	"os"
)

const (
	dsnEnvName = "PG_DSN"
)

type PGConfig interface {
	DSN() string
}

type pgConfig struct {
	dsn string
}

func NewPGConfig() (PGConfig, error) {

	dsn := os.Getenv(dsnEnvName)
	if len(dsn) == 0 {
		return nil, errors.New("pg dsn not found")
	}
	fmt.Println(dsn)
	return &pgConfig{
		dsn: dsn,
	}, nil
}

func (cfg *pgConfig) DSN() string {
	return cfg.dsn
}


internal/config/swagger.go
--------------------------------------------------------------------------------
package config

import (
	"net"
	"os"

	"github.com/pkg/errors"
)

const (
	swaggerHostEnvName = "SWAGGER_HOST"
	swaggerPortEnvName = "SWAGGER_PORT"
)

type SwaggerConfig interface {
	Address() string
}

type swaggerConfig struct {
	host string
	port string
}

func NewSwaggerConfig() (SwaggerConfig, error) {
	host := os.Getenv(swaggerHostEnvName)
	if len(host) == 0 {
		return nil, errors.New("swagger host not found")
	}

	port := os.Getenv(swaggerPortEnvName)
	if len(port) == 0 {
		return nil, errors.New("swagger port not found")
	}

	return &swaggerConfig{
		host: host,
		port: port,
	}, nil
}

func (cfg *swaggerConfig) Address() string {
	return net.JoinHostPort(cfg.host, cfg.port)
}


modules/auth/handler/converter/user.go
--------------------------------------------------------------------------------
package converter

import (
	modelApi "diploma/modules/auth/handler/model"
	"diploma/modules/auth/model"
)

func ToServiceFromRegisterInput(user modelApi.RegisterInput) *model.AuthUser {
	return &model.AuthUser{
		Info: &model.UserInfo{
			Name:        user.Name,
			PhoneNumber: user.PhoneNumber,
		},
		Password: user.Password,
	}
}


modules/auth/handler/login.go
--------------------------------------------------------------------------------
package handler

import (
	"net/http"

	"diploma/pkg/validator"

	modelApi "diploma/modules/auth/handler/model"

	"github.com/gin-gonic/gin"
)

// Login godoc
// @Summary      User login
// @Description  Login user and return tokens
// @Tags         auth
// @Accept       json
// @Produce      json
// @Param        input body modelApi.LoginInput true "Login input"
// @Success      200  {object}  modelApi.LoginResponse
// @Failure      401  {object}  modelApi.ErrorResponse
// @Router       /api/auth/login [post]
func (h *AuthHandler) Login(c *gin.Context) {
	var form struct {
		modelApi.LoginInput
		validator.Validator
	}

	if err := c.ShouldBindJSON(&form); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	form.CheckField(validator.NotBlank(form.PhoneNumber), "phone_number", "Phone number cannot be blank")
	form.CheckField(validator.NotBlank(form.Password), "password", "Password cannot be blank")

	if !form.Valid() {
		c.JSON(http.StatusBadRequest, gin.H{"errors": form.Errors})
		return
	}

	accessToken, refreshToken, err := h.service.Login(c.Request.Context(), form.PhoneNumber, form.Password)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, modelApi.LoginResponse{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	})
}


modules/auth/handler/model/user.go
--------------------------------------------------------------------------------
package model

type RegisterInput struct {
	Name            string `json:"name" example:"John Doe"`
	PhoneNumber     string `json:"phone_number" example:"+123456789"`
	Password        string `json:"password" example:"secure123"`
	ConfirmPassword string `json:"confirm_password" example:"secure123"`
}

type RegisterResponse struct {
	ID int64 `json:"id" example:"1"`
}

type LoginInput struct {
	PhoneNumber string `json:"phone_number" example:"+123456789"`
	Password    string `json:"password" example:"secure123"`
}

type LoginResponse struct {
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
}

type ErrorResponse struct {
	Err string `json:"error"`
}


modules/auth/handler/register.go
--------------------------------------------------------------------------------
package handler

import (
	"log"
	"net/http"

	"diploma/pkg/validator"

	"diploma/modules/auth/handler/converter"
	modelApi "diploma/modules/auth/handler/model"
	"diploma/modules/auth/model"

	"github.com/gin-gonic/gin"
)

// Register godoc
// @Summary      User registration
// @Description  Register a new user
// @Tags         auth
// @Accept       json
// @Produce      json
// @Param        input body modelApi.RegisterInput true "Register input"
// @Success      201  {object}  modelApi.RegisterResponse
// @Failure      400  {object}  modelApi.ErrorResponse
// @Router       /api/auth/register [post]
func (h *AuthHandler) Register(c *gin.Context) {

	var form struct {
		modelApi.RegisterInput
		validator.Validator
	}

	if err := c.ShouldBindJSON(&form); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	form.CheckField(validator.NotBlank(form.Name), "name", "Name cannot be blank")
	form.CheckField(validator.NotBlank(form.PhoneNumber), "phone_number", "Phone number cannot be blank")
	form.CheckField(validator.NotBlank(form.Password), "password", "Password cannot be blank")
	form.CheckField(form.Password == form.ConfirmPassword, "confirm_password", "Passwords do not match")

	if !form.Valid() {
		c.JSON(http.StatusBadRequest, gin.H{"errors": form.Errors})
		return
	}
	authUser := converter.ToServiceFromRegisterInput(form.RegisterInput)
	authUser.Info.Role = model.CustomerRole
	id, err := h.service.Register(c.Request.Context(), authUser)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	log.Printf("Registered user with id: %d", id)

	c.JSON(http.StatusCreated, modelApi.RegisterResponse{
		ID: id,
	})
}


modules/auth/handler/server.go
--------------------------------------------------------------------------------
package handler

import (
	"context"
	"diploma/modules/auth/model"
)

type AuthHandler struct {
	service IAuthService
}

func NewHandler(service IAuthService) *AuthHandler {
	return &AuthHandler{service: service}
}

type IAuthService interface {
	Register(ctx context.Context, user *model.AuthUser) (int64, error)
	Login(ctx context.Context, phoneNumber string, password string) (accessToken string, refreshToken string, err error)
}


modules/auth/jwt/jwt.go
--------------------------------------------------------------------------------
package jwt

import (
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

type JSONWebToken struct {
	jwtKey []byte
}

func NewJSONWebToken(jwtSecret string) *JSONWebToken {
	return &JSONWebToken{
		jwtKey: []byte(jwtSecret),
	}
}

type Claims struct {
	Role     int    `json:"role"`
	UserID   int64  `json:"id"`
	Username string `json:"username"`
	jwt.RegisteredClaims
}

func (sa *JSONWebToken) GetJWTKey() []byte {
	return sa.jwtKey
}

func (sa *JSONWebToken) GenerateJSONWebTokens(id int64, username string, role int) (string, string, error) {
	accessToken, err := sa.generateShortLivedJSONWebToken(id, role, username)
	if err != nil {
		return "", "", err
	}

	refreshToken, err := sa.generateLongLivedJSONWebToken(id, role, username)
	if err != nil {
		return "", "", err
	}

	return accessToken, refreshToken, nil
}

func (sa *JSONWebToken) generateShortLivedJSONWebToken(id int64, role int, username string) (string, error) {
	expiration := time.Now().Add(3000 * time.Hour)
	return sa.generateJSONWebToken(id, role, username, expiration)
}

func (sa *JSONWebToken) generateLongLivedJSONWebToken(id int64, role int, username string) (string, error) {
	expiration := time.Now().Add(24 * time.Hour)
	return sa.generateJSONWebToken(id, role, username, expiration)
}

func (sa *JSONWebToken) generateJSONWebToken(id int64, role int, username string, expirationTime time.Time) (string, error) {
	claims := &Claims{
		Username: username,
		UserID:   id,
		Role:     role,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expirationTime),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(sa.jwtKey)
}

func (sa *JSONWebToken) RefreshAccessToken(refreshToken string) (string, error) {
	token, err := jwt.ParseWithClaims(refreshToken, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		return sa.jwtKey, nil
	})
	if err != nil {
		return "", err
	}

	claims, ok := token.Claims.(*Claims)
	if !ok || !token.Valid {
		return "", errors.New("invalid refresh token")
	}

	newAccessToken, err := sa.generateShortLivedJSONWebToken(claims.UserID, claims.Role, claims.Username)
	if err != nil {
		return "", err
	}
	return newAccessToken, nil
}

func (sa *JSONWebToken) VerifyToken(tokenStr string) (*Claims, error) {
	token, err := jwt.ParseWithClaims(tokenStr, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		// Ensure the token's signing method is HMAC (HS256).
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return sa.jwtKey, nil
	})
	if err != nil {
		return nil, err
	}

	claims, ok := token.Claims.(*Claims)
	if !ok || !token.Valid {
		return nil, errors.New("invalid token")
	}
	return claims, nil
}

func ExtractTokenFromHeader(r *http.Request) (string, error) {
	authHeader := r.Header.Get("Authorization")
	if authHeader == "" {
		return "", errors.New("authorization header is missing")
	}

	parts := strings.Split(authHeader, " ")
	if len(parts) != 2 || parts[0] != "Bearer" {
		return "", errors.New("authorization header format must be Bearer {token}")
	}
	return parts[1], nil
}


modules/auth/middleware/auth.go
--------------------------------------------------------------------------------
package middleware

import (
	"context"
	"diploma/modules/auth/jwt"
	contextkeys "diploma/pkg/context-keys"
	"net/http"

	"github.com/gin-gonic/gin"
)

// AuthMiddleware is the middleware that checks if a user is authenticated.
func (m *AuthMiddleware) AuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		token, err := jwt.ExtractTokenFromHeader(c.Request)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
			c.Abort() // Stop further processing of the request
			return
		}
		user, err := m.jwt.VerifyToken(token)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
			c.Abort() // Stop further processing of the request
			return
		}
		// Save the user info in the context
		ctx := context.WithValue(c.Request.Context(), contextkeys.UserKey, user)
		c.Request = c.Request.WithContext(ctx)

		c.Next() // Proceed to the next handler
	}
}


modules/auth/middleware/server.go
--------------------------------------------------------------------------------
package middleware

import (
	"diploma/modules/auth/jwt"
)

type AuthMiddleware struct {
	jwt *jwt.JSONWebToken
}

func NewAuthMiddleware(jwt *jwt.JSONWebToken) *AuthMiddleware {
	return &AuthMiddleware{
		jwt: jwt,
	}
}


modules/auth/model/errors.go
--------------------------------------------------------------------------------
package model

import "errors"

var (
	ErrInvalidCredentials = errors.New("models: invalid credentials")

	ErrDuplicateNumber = errors.New("models: duplicate email")

	ErrNoRows = errors.New("models: no rows")
)


modules/auth/model/user.go
--------------------------------------------------------------------------------
package model

import (
	"database/sql"
	"time"
)

const (
	CustomerRole = iota
	SupplierRole
	AdminRole
)

type User struct {
	ID        int64
	Info      *UserInfo
	CreatedAt time.Time
	UpdatedAt sql.NullTime
}

type UserInfo struct {
	Name        string
	PhoneNumber string
	Role        int
}

type AuthUser struct {
	ID             int64
	Info           *UserInfo
	Password       string
	HashedPassword string
}


modules/auth/repository/user/converter/user.go
--------------------------------------------------------------------------------
package converter

import (
	"diploma/modules/auth/model"
	modelRepo "diploma/modules/auth/repository/user/model"
)

func ToUserFromRepo(user *modelRepo.User) *model.User {
	return &model.User{
		ID:        user.ID,
		Info:      ToUserInfoFromRepo(user.Info),
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
	}
}

func ToUserInfoFromRepo(info *modelRepo.UserInfo) *model.UserInfo {
	return &model.UserInfo{
		Name:        info.Name,
		PhoneNumber: info.PhoneNumber,
		Role:        info.Role,
	}
}

func ToAuthUserFromRepo(user *modelRepo.AuthUser) *model.AuthUser {
	return &model.AuthUser{
		ID:             user.ID,
		Info:           ToUserInfoFromRepo(user.Info),
		HashedPassword: user.HashedPassword,
	}
}


modules/auth/repository/user/model/user.go
--------------------------------------------------------------------------------
package model

import (
	"database/sql"
	"time"
)

type User struct {
	ID        int64
	Info      *UserInfo
	CreatedAt time.Time
	UpdatedAt sql.NullTime
}

type UserInfo struct {
	Role        int
	Name        string
	PhoneNumber string
}

type AuthUser struct {
	ID             int64
	Info           *UserInfo
	Password       string
	HashedPassword string
}


modules/auth/repository/user/reposotiry.go
--------------------------------------------------------------------------------
package user

import (
	"diploma/modules/auth/model"
	"diploma/pkg/client/db"
	"context"
	"time"

	converter "diploma/modules/auth/repository/user/converter"
	modelRepo "diploma/modules/auth/repository/user/model"

	sq "github.com/Masterminds/squirrel"
)

const (
	tableName = "users"

	idColumn             = "id"
	nameColumn           = "name"
	phoneNumberColumn    = "phone_number"
	hashedPasswordColumn = "hashed_password"
	roleColumn           = "role"
	createdAtColumn      = "created_at"
	updatedAtColumn      = "updated_at"
)

type repo struct {
	db db.Client
}

func NewRepository(db db.Client) *repo {
	return &repo{db: db}
}

func (r *repo) Create(ctx context.Context, user *model.AuthUser) (int64, error) {
	builder := sq.Insert(tableName).
		PlaceholderFormat(sq.Dollar).
		Columns(nameColumn, phoneNumberColumn, hashedPasswordColumn, roleColumn).
		Values(user.Info.Name, user.Info.PhoneNumber, user.HashedPassword, user.Info.Role).
		Suffix("RETURNING id")

	query, args, err := builder.ToSql()
	if err != nil {
		return 0, err
	}

	q := db.Query{
		Name:     "user_repository.Create",
		QueryRaw: query,
	}

	var id int64
	err = r.db.DB().QueryRowContext(ctx, q, args...).Scan(&id)
	if err != nil {
		return 0, err
	}

	return id, nil
}

func (r *repo) GetById(ctx context.Context, id int64) (*model.User, error) {
	builder := sq.Select(idColumn, nameColumn, phoneNumberColumn, roleColumn, createdAtColumn, updatedAtColumn).
		PlaceholderFormat(sq.Dollar).
		From(tableName).
		Where(sq.Eq{idColumn: id})

	query, args, err := builder.ToSql()

	if err != nil {
		return nil, err
	}

	q := db.Query{
		Name:     "user_repository.Get",
		QueryRaw: query,
	}

	var user modelRepo.User
	var userInfo modelRepo.UserInfo
	err = r.db.DB().QueryRowContext(ctx, q, args...).Scan(&user.ID, &userInfo.Name, &userInfo.PhoneNumber, &userInfo.Role, &user.CreatedAt, &user.UpdatedAt)
	if err != nil {
		return nil, err
	}
	user.Info = &userInfo

	return converter.ToUserFromRepo(&user), nil
}

func (r *repo) GetByPhoneNumber(ctx context.Context, phoneNumber string) (*model.AuthUser, error) {
	builder := sq.Select(idColumn, nameColumn, phoneNumberColumn, roleColumn, hashedPasswordColumn).
		PlaceholderFormat(sq.Dollar).
		From(tableName).
		Where(sq.Eq{phoneNumberColumn: phoneNumber})

	query, args, err := builder.ToSql()

	if err != nil {
		return nil, err
	}

	q := db.Query{
		Name:     "user_repository.Get",
		QueryRaw: query,
	}

	var user modelRepo.AuthUser
	var userInfo modelRepo.UserInfo
	err = r.db.DB().QueryRowContext(ctx, q, args...).Scan(&user.ID, &userInfo.Name, &userInfo.PhoneNumber, &userInfo.Role, &user.HashedPassword)
	if err != nil {
		return nil, err
	}
	user.Info = &userInfo

	return converter.ToAuthUserFromRepo(&user), nil
}

func (r *repo) Delete(ctx context.Context, id int64) error {
	builder := sq.Delete(tableName).
		Where(sq.Eq{idColumn: id}).
		PlaceholderFormat(sq.Dollar)

	query, args, err := builder.ToSql()
	if err != nil {
		return err
	}

	q := db.Query{
		Name:     "user_repository.Delete",
		QueryRaw: query,
	}

	_, err = r.db.DB().ExecContext(ctx, q, args...)
	if err != nil {
		return err
	}

	return nil
}

func (r *repo) Update(ctx context.Context, id int64, info *model.UserInfo) error {
	builder := sq.Update(tableName).
		PlaceholderFormat(sq.Dollar).
		Where(sq.Eq{idColumn: id}).
		Set(updatedAtColumn, time.Now())

	if info.Name != "" {
		builder = builder.Set(nameColumn, info.Name)
	}
	if info.PhoneNumber != "" {
		builder = builder.Set(phoneNumberColumn, info.PhoneNumber)
	}

	query, args, err := builder.ToSql()
	if err != nil {
		return err
	}

	q := db.Query{
		Name:     "user_repository.Update",
		QueryRaw: query,
	}

	_, err = r.db.DB().ExecContext(ctx, q, args...)
	if err != nil {
		return err
	}
	return nil
}


modules/auth/routes.go
--------------------------------------------------------------------------------
package auth

import (
	"diploma/modules/auth/handler"

	"github.com/gin-gonic/gin"
)

func RegisterRoutes(router *gin.RouterGroup, h *handler.AuthHandler) {
	authRoutes := router.Group("/auth")
	{
		authRoutes.POST("/register", h.Register)
		authRoutes.POST("/login", h.Login)
	}
}


modules/auth/service/auth/register.go
--------------------------------------------------------------------------------
package auth

import (
	"context"
	"errors"

	"diploma/modules/auth/model"
	passwordutil "diploma/pkg/password-util"
)

func (s *authServ) Register(ctx context.Context, user *model.AuthUser) (int64, error) {
	var id int64
	var err error
	user.HashedPassword, err = passwordutil.HashPassword(user.Password)
	if err != nil {
		return 0, err
	}
	if user.Info.Role == model.AdminRole {
		return 0, errors.New("admin role is not allowed")
	}
	err = s.txManager.ReadCommitted(ctx, func(ctx context.Context) error {
		var errTx error
		id, errTx = s.authRepository.Create(ctx, user)
		if errTx != nil {
			return errTx
		}

		_, errTx = s.authRepository.GetById(ctx, id)
		if errTx != nil {
			return errTx
		}

		return nil
	})

	if err != nil {
		return 0, err
	}

	return id, nil
}

func (s *authServ) Login(ctx context.Context, phoneNumber string, password string) (accessToken string, refreshToken string, err error) {
	authUser, err := s.authRepository.GetByPhoneNumber(ctx, phoneNumber)

	if err != nil {
		if errors.Is(err, model.ErrNoRows) {
			return "", "", model.ErrInvalidCredentials
		}
	}

	if !passwordutil.CheckPasswordHash(password, authUser.HashedPassword) {
		return "", "", model.ErrInvalidCredentials
	}
	return s.jwt.GenerateJSONWebTokens(authUser.ID, authUser.Info.Name, authUser.Info.Role)

}


modules/auth/service/auth/service.go
--------------------------------------------------------------------------------
package auth

import (
	"diploma/modules/auth/model"
	"diploma/pkg/client/db"
	"context"
)

type authServ struct {
	authRepository IAuthRepository
	jwt            IJWT
	txManager      db.TxManager
}

func NewService(
	authRepository IAuthRepository,
	jwt IJWT,
	txManager db.TxManager,
) *authServ {
	return &authServ{
		authRepository: authRepository,
		jwt:            jwt,
		txManager:      txManager,
	}
}

type IAuthRepository interface {
	Create(ctx context.Context, user *model.AuthUser) (int64, error)
	GetById(ctx context.Context, id int64) (*model.User, error)
	GetByPhoneNumber(ctx context.Context, phoneNumber string) (*model.AuthUser, error)
}

type IJWT interface {
	GenerateJSONWebTokens(id int64, username string, role int) (accessToken string, refreshToken string, err error)
	RefreshAccessToken(refreshToken string) (string, error)
	// VerifyToken(accessToken string) (bool, error)
}


modules/cart/client/order/order.go
--------------------------------------------------------------------------------
package order

import (
	"context"
	"diploma/modules/cart/model"
	orderModel "diploma/modules/order/model"
	order "diploma/modules/order/service"
	"fmt"
)

type OrderClient struct {
	orderService *order.OrderService
}

func NewClient(orderService *order.OrderService) *OrderClient {
	return &OrderClient{orderService: orderService}
}

func (a *OrderClient) CreateOrder(ctx context.Context, cart *model.Cart) error {
	orders := cartToOrder(cart)
	fmt.Println(orders)
	if err := a.orderService.CreateOrder(ctx, orders); err != nil {
		return err
	}

	return nil
}

func cartToOrder(cart *model.Cart) []*orderModel.Order {
	res := make([]*orderModel.Order, 0, len(cart.Suppliers))
	for _, supplier := range cart.Suppliers {

		order := orderModel.Order{
			CustomerID:  cart.CustomerID,
			SupplierID:  supplier.ID,
			ProductList: cartProductListToOrderProductList(supplier.ProductList),
		}
		res = append(res, &order)
	}
	return res
}

func cartProductListToOrderProductList(cartProducts []model.Product) []*orderModel.OrderProduct {
	orderProducts := make([]*orderModel.OrderProduct, 0, len(cartProducts))
	for _, cp := range cartProducts {
		orderProducts = append(orderProducts, &orderModel.OrderProduct{
			ProductID: cp.ID,
			Quantity:  cp.Quantity,
			Price:     cp.Price,
		})
	}
	return orderProducts
}


modules/cart/client/supplier/supplier.go
--------------------------------------------------------------------------------
package supplier

import (
	"context"
	"diploma/modules/cart/model"
	supplierModel "diploma/modules/supplier/model"
)

type SupplierClient struct {
	supplierService ISupplierService
}

func NewClient(supplierService ISupplierService) *SupplierClient {
	return &SupplierClient{supplierService: supplierService}
}

type ISupplierService interface {
	SupplierListByIDList(ctx context.Context, idList []int64) ([]supplierModel.Supplier, error)
}

func (a *SupplierClient) SupplierListByIDList(ctx context.Context, IDList []int64) ([]model.Supplier, error) {

	suppliers, err := a.supplierService.SupplierListByIDList(ctx, IDList)
	if err != nil {
		return nil, err
	}
	var res []model.Supplier
	for _, supplier := range suppliers {
		res = append(res, model.Supplier{
			ID:                 supplier.ID,
			Name:               supplier.Name,
			OrderAmount:        supplier.OrderAmount,
			DeliveryFee:        supplier.DeliveryFee,
			FreeDeliveryAmount: supplier.FreeDeliveryAmount,
		})
	}
	return res, nil
}


modules/cart/handler/cart.go
--------------------------------------------------------------------------------
package handler

import (
	"diploma/modules/auth/jwt"
	"diploma/modules/cart/handler/converter"
	modelApi "diploma/modules/cart/handler/model"
	"diploma/modules/cart/model"
	contextkeys "diploma/pkg/context-keys"
	"fmt"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
)

// Register godoc
// @Summary      Put product to Card
// @Description  --
// @Tags         cart
// @Accept       json
// @Produce      json
// @Security     ApiKeyAuth
// @Param        input body modelApi.AddProductToCartInput true "Put Card input"
// @Success      200  {object}  modelApi.AddProductToCardResponse
// @Failure      400  {object}  modelApi.ErrorResponse
// @Router       /api/cart/add [post]
func (h *CartHandler) AddProductToCard(c *gin.Context) {

	claims, ok := c.Request.Context().Value(contextkeys.UserKey).(*jwt.Claims)

	if !ok || claims == nil {
		c.JSON(http.StatusUnauthorized, modelApi.ErrorResponse{Err: modelApi.ErrUnauthorized.Error()})
		return
	}

	var input modelApi.AddProductToCartInput
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, modelApi.ErrorResponse{Err: err.Error()})
		return
	}
	input.CustomerID = claims.UserID

	fmt.Println(input)
	err := h.service.AddProductToCard(c.Request.Context(), converter.ToServiceCardInputFromAPI(&input))
	if err != nil {
		c.JSON(http.StatusInternalServerError, modelApi.ErrorResponse{Err: err.Error()})
		return
	}

	c.JSON(http.StatusOK, modelApi.AddProductToCardResponse{Status: "ok"})
}

// @Summary      get cart
// @Description  --
// @Tags         cart
// @Accept       json
// @Produce      json
// @Security     ApiKeyAuth
// @Success      200  {object} modelApi.GetCartResponse
// @Failure      400  {object}  modelApi.ErrorResponse
// @Router       /api/cart [get]
func (h *CartHandler) GetCart(c *gin.Context) {
	claims, ok := c.Request.Context().Value(contextkeys.UserKey).(*jwt.Claims)

	if !ok {
		c.JSON(http.StatusUnauthorized, modelApi.ErrorResponse{Err: modelApi.ErrUnauthorized.Error()})
		return
	}

	cart, err := h.service.Cart(c.Request.Context(), claims.UserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, modelApi.ErrorResponse{Err: err.Error()})
		return
	}
	c.JSON(http.StatusOK, converter.ToAPIGetCartFromService(cart))
}

// DeleteProductFromCart godoc
// @Summary      Delete product from cart
// @Description  Deletes given quantity of product by product_id and supplier_id from cart
// @Tags         cart
// @Accept       json
// @Produce      json
// @Security     ApiKeyAuth
// @Param        product_id   query     int  true  "Product ID"
// @Param        supplier_id  query     int  true  "Supplier ID"
// @Param        quantity     query     int  false "Quantity to delete (default 1)"
// @Success      200  {object} map[string]string
// @Failure      400  {object} map[string]string
// @Failure      401  {object} map[string]string
// @Failure      500  {object} map[string]string
// @Router       /api/cart/delete [delete]
func (h *CartHandler) DeleteProductFromCart(c *gin.Context) {
	claims, ok := c.Request.Context().Value(contextkeys.UserKey).(*jwt.Claims)
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}

	productIDStr := c.Query("product_id")
	supplierIDStr := c.Query("supplier_id")
	quantityStr := c.DefaultQuery("quantity", "1")

	if productIDStr == "" || supplierIDStr == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "missing product_id or supplier_id"})
		return
	}

	productID, err := strconv.ParseInt(productIDStr, 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product_id"})
		return
	}

	supplierID, err := strconv.ParseInt(supplierIDStr, 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid supplier_id"})
		return
	}

	quantity, err := strconv.Atoi(quantityStr)
	if err != nil || quantity < 1 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid quantity"})
		return
	}

	query := &model.PutCartQuery{
		CustomerID: claims.UserID,
		ProductID:  productID,
		SupplierID: supplierID,
		Quantity:   quantity,
	}

	err = h.service.DeleteProductFromCart(c.Request.Context(), query)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "product deleted from cart"})
}


modules/cart/handler/checkout.go
--------------------------------------------------------------------------------
package handler

import (
	"diploma/modules/auth/jwt"
	modelApi "diploma/modules/cart/handler/model"
	"diploma/modules/cart/model"
	contextkeys "diploma/pkg/context-keys"
	"errors"
	"net/http"

	"github.com/gin-gonic/gin"
)

// Checkout godoc
// @Summary Process checkout operation
// @Description Processes the checkout of the authenticated user's cart.
// @Tags cart
// @Security ApiKeyAuth
// @Accept json
// @Produce json
// @Success 200 {object} map[string]interface{} "Checkout status"
// @Failure 401 {object} modelApi.ErrorResponse "Unauthorized"
// @Failure 500 {object} modelApi.ErrorResponse "Internal Server Error"
// @Router /api/cart/checkout [post]
func (h *CartHandler) Checkout(c *gin.Context) {
	claims, ok := c.Request.Context().Value(contextkeys.UserKey).(*jwt.Claims)

	if !ok {
		c.JSON(http.StatusUnauthorized, modelApi.ErrorResponse{Err: modelApi.ErrUnauthorized.Error()})
		return
	}

	ok, err := h.service.Checkout(c.Request.Context(), claims.UserID)
	if err != nil {
		if errors.Is(err, model.ErrInvalidCart) {
			c.JSON(http.StatusBadRequest, modelApi.ErrorResponse{Err: err.Error()})
			return
		}

		c.JSON(http.StatusInternalServerError, modelApi.ErrorResponse{Err: err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"status": ok})
}


modules/cart/handler/converter/add-product.go
--------------------------------------------------------------------------------
package converter

import (
	modelApi "diploma/modules/cart/handler/model"
	"diploma/modules/cart/model"
)

func ToServiceCardInputFromAPI(input *modelApi.AddProductToCartInput) *model.PutCartQuery {
	return &model.PutCartQuery{
		CustomerID: input.CustomerID,
		ProductID:  input.ProductID,
		Quantity:   input.Quantity,
		SupplierID: input.SupplierID,
	}
}

func ToAPIGetCartFromService(card *model.Cart) *modelApi.GetCartResponse {
	return &modelApi.GetCartResponse{
		Total:      card.Total,
		CustomerID: card.CustomerID,
		Suppliers:  ToAPISuppliersFromService(card.Suppliers),
	}
}

func ToAPISuppliersFromService(suppliers []model.Supplier) []modelApi.Supplier {
	apiSuppliers := make([]modelApi.Supplier, len(suppliers))
	for i, supplier := range suppliers {
		apiSuppliers[i] = modelApi.Supplier{
			ID:                 supplier.ID,
			Name:               supplier.Name,
			OrderAmount:        supplier.OrderAmount,
			TotalAmount:        supplier.TotalAmount,
			FreeDeliveryAmount: supplier.FreeDeliveryAmount,
			DeliveryFee:        supplier.DeliveryFee,
			ProductList:        ToAPIProductsFromService(supplier.ProductList),
		}
	}
	return apiSuppliers
}

func ToAPIProductsFromService(products []model.Product) []modelApi.Product {
	apiProducts := make([]modelApi.Product, len(products))
	for i, product := range products {
		apiProducts[i] = modelApi.Product{
			ID:       product.ID,
			Name:     product.Name,
			Price:    product.Price,
			Quantity: product.Quantity,
			ImageUrl:    product.ImageUrl,
		}
	}
	return apiProducts
}


modules/cart/handler/model/put-card-input.go
--------------------------------------------------------------------------------
package model

import "errors"

var (
	ErrUnauthorized = errors.New("api: unauthorized")
)

type AddProductToCartInput struct {
	Quantity   int   `json:"quantity"`
	ProductID  int64 `json:"product_id"`
	SupplierID int64 `json:"supplier_id"`
	CustomerID int64 `json:"-"`
}

type AddProductToCardResponse struct {
	Status string `json:"status"`
}

type GetCardInput struct {
	CustomerID int64 `json:"CustomerID"`
}

type GetCartResponse struct {
	Total      int        `json:"total"`
	CustomerID int64      `json:"customer_id"`
	Suppliers  []Supplier `json:"suppliers"`
}

type Supplier struct {
	OrderAmount        int       `json:"order_amount`
	TotalAmount        int       `json:"total_amount"`
	FreeDeliveryAmount int       `json:"free_delivery_amount"`
	DeliveryFee        int       `json:"delivery_fee"`
	ID                 int64     `json:"id"`
	Name               string    `json:"name"`
	ProductList        []Product `json:"product_list"`
}

type Product struct {
	Price    int    `json:"price"`
	Quantity int    `json:"quantity"`
	ID       int64  `json:"id"`
	Name     string `json:"name"`
	ImageUrl string `json:"image"`
}

type DeleteProductFromCartInput struct {
	CustomerID int64 `json:"customer_id"`
	ProductID  int64 `json:"product_id"`
	SupplierID int64 `json:"supplier_id"`
	Quantity   int   `json:"quantity"`
}

type ErrorResponse struct {
	Err string `json:"error"`
}


modules/cart/handler/server.go
--------------------------------------------------------------------------------
package handler

import (
	"context"
	"diploma/modules/cart/model"
)

type CartHandler struct {
	service ICartService
}

func NewHandler(service ICartService) *CartHandler {
	return &CartHandler{service: service}
}

type ICartService interface {
	Checkout(ctx context.Context, userID int64) (bool, error)
	Cart(ctx context.Context, userID int64) (*model.Cart, error)
	AddProductToCard(ctx context.Context, input *model.PutCartQuery) error
	DeleteProductFromCart(ctx context.Context, input *model.PutCartQuery) error
	// DeleteProductFromCart(ctx context.Context, input *model.DeleteProductQuery) error
}


modules/cart/model/cart.go
--------------------------------------------------------------------------------
package model

type PutCartQuery struct {
	Quantity   int
	Price      int
	ProductID  int64
	SupplierID int64
	CustomerID int64
	CartID     int64
}

type Cart struct {
	ID         int64
	Total      int
	CustomerID int64
	Suppliers  []Supplier
}

type Supplier struct {
	OrderAmount        int
	TotalAmount        int
	FreeDeliveryAmount int
	DeliveryFee        int
	ID                 int64
	Name               string
	ProductList        []Product
}

type Product struct {
	Price    int
	Quantity int
	ID       int64
	Name     string
	ImageUrl string
}

type DeleteProductQuery struct {
	CustomerID int64
	ProductID  int64
	Quantity   int
	SupplierID int64
}


modules/cart/model/errors.go
--------------------------------------------------------------------------------
package model

import "errors"

var (
	ErrInvalidCredentials = errors.New("models: invalid credentials")

	ErrDuplicateNumber = errors.New("models: duplicate email")

	ErrNoRows = errors.New("models: no rows")

	ErrInvalidCart = errors.New("models: invalid cart")
)


modules/cart/repository/cart.go
--------------------------------------------------------------------------------
package repository

import (
	"context"
	"database/sql"
	"diploma/modules/cart/model"
	"diploma/modules/cart/repository/converter"
	modelRepo "diploma/modules/cart/repository/model"
	"diploma/pkg/client/db"
	"errors"
	"fmt"

	sq "github.com/Masterminds/squirrel"
)

func (r *cartRepo) CreateCart(ctx context.Context, userID int64) (int64, error) {
	builder := sq.Insert(cartsTable).
		PlaceholderFormat(sq.Dollar).
		Columns(cCustomerIDColumn).
		Values(userID).
		Suffix("RETURNING id")

	query, args, err := builder.ToSql()
	if err != nil {
		return 0, err
	}

	q := db.Query{
		Name:     "cart_repository.Create",
		QueryRaw: query,
	}

	var cartID int64

	err = r.db.DB().QueryRowContext(ctx, q, args...).Scan(&cartID)
	if err != nil {
		return 0, err
	}
	return cartID, nil
}

func (r *cartRepo) Cart(ctx context.Context, userID int64) (*model.Cart, error) {
	builder := sq.Select(cIDColumn, cTotalColumn, cCustomerIDColumn).
		PlaceholderFormat(sq.Dollar).
		From(cartsTable).
		Where(sq.Eq{cCustomerIDColumn: userID})

	query, args, err := builder.ToSql()

	if err != nil {
		return nil, err
	}

	q := db.Query{
		Name:     "cart_repository.Get",
		QueryRaw: query,
	}

	var cart modelRepo.Cart

	err = r.db.DB().QueryRowContext(ctx, q, args...).Scan(&cart.ID, &cart.Total, &cart.CustomerID)
	if err != nil {
		if errors.As(sql.ErrNoRows, &err) {
			return nil, model.ErrNoRows
		}
		return nil, err
	}
	return converter.ToServiceCartFromRepo(&cart), nil
}

func (r *cartRepo) UpdateCartTotal(ctx context.Context, cartID int64, total int) error {
	builder := sq.Update(cartsTable).
		PlaceholderFormat(sq.Dollar).
		Set(cTotalColumn, total).
		Where(sq.Eq{cIDColumn: cartID})

	query, args, err := builder.ToSql()

	if err != nil {
		return err
	}

	q := db.Query{
		Name:     "cart_repository.UpdateTotal",
		QueryRaw: query,
	}

	result, err := r.db.DB().ExecContext(ctx, q, args...)
	if err != nil {
		return fmt.Errorf("error executing query: %v", err)
	}
	if result.RowsAffected() == 0 {
		return fmt.Errorf("no rows updated")
	}

	return nil
}

func (r *cartRepo) GetCartItems(ctx context.Context, cartID int64) ([]model.Supplier, error) {
	// Query to select cart items and product details
	builder := sq.Select(
		cartItemTable+"."+ciProductIDColumn,
		cartItemTable+"."+ciSupplierIDColumn,
		cartItemTable+"."+ciQuantityColumn,
		cartItemTable+"."+ciPriceColumn,
		productsTable+"."+nameColumn+" AS product_name",
		productsTable+"."+imageURLColumn,
	).
		PlaceholderFormat(sq.Dollar).
		From(cartItemTable).
		Join(productsTable + " ON " + cartItemTable + "." + ciProductIDColumn + "=" + productsTable + "." + "id").
		Where(sq.Eq{ciCartIDColumn: cartID})

	query, args, err := builder.ToSql()

	if err != nil {
		return nil, err
	}

	q := db.Query{
		Name:     "cart_repository.GetCartItems",
		QueryRaw: query,
	}

	rows, err := r.db.DB().QueryContext(ctx, q, args...)
	if err != nil {
		if errors.As(sql.ErrNoRows, &err) {
			return nil, model.ErrNoRows
		}
		return nil, err
	}
	defer rows.Close()

	var items []modelRepo.CartItem
	for rows.Next() {
		var item modelRepo.CartItem

		if err := rows.Scan(&item.ProductID, &item.SupplierID, &item.Quantity, &item.Price, &item.ProductName, &item.ProductImageURL); err != nil {
			return nil, err
		}

		items = append(items, item)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return converter.ToServiceSupplierFromRepo(items), nil
}

func (r *cartRepo) DeleteCart(ctx context.Context, cartID int64) error {
	builder := sq.Delete(cartsTable).
		PlaceholderFormat(sq.Dollar).
		Where(sq.Eq{cIDColumn: cartID})

	query, args, err := builder.ToSql()

	if err != nil {
		return err
	}

	q := db.Query{
		Name:     "cart_repository.Delete",
		QueryRaw: query,
	}

	result, err := r.db.DB().ExecContext(ctx, q, args...)
	if err != nil {
		return fmt.Errorf("error executing query: %v", err)
	}
	if result.RowsAffected() == 0 {
		return fmt.Errorf("no rows deleted")
	}

	return nil
}